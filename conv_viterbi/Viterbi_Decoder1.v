// -------------------------------------------------------------
// 
// File Name: C:\Users\bryan\Downloads\viterbi\gm_hdlcoder_commviterbi\Viterbi_Decoder1.v
// Created: 2024-06-16 16:50:07
// 
// Generated by MATLAB 23.2, HDL Coder 23.2, and Simulink 23.2
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: Viterbi_Decoder1
// Source Path: gm_hdlcoder_commviterbi/Viterbi Decoder Subsystem/Viterbi Decoder1
// Hierarchy Level: 1
// Model version: 10.10
// 
// Top level of Viterbi Decoder, consists of three basic components: Branch Metric, ACS,and Traceback 
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module Viterbi_Decoder1
          (clk,
           reset,
           enb,
           Viterbi_Decoder1_in_0,
           Viterbi_Decoder1_in_1,
           decoded);


  input   clk;
  input   reset;
  input   enb;
  input   Viterbi_Decoder1_in_0;  // boolean
  input   Viterbi_Decoder1_in_1;  // boolean
  output  decoded;


  wire [1:0] Viterbi_Decoder1_in;  // boolean [2]
  reg  [1:0] regin;  // boolean [2]
  wire [1:0] bMet_0;  // ufix2
  wire [1:0] bMet_1;  // ufix2
  wire [1:0] bMet_2;  // ufix2
  wire [1:0] bMet_3;  // ufix2
  wire [1:0] bMet [0:3];  // ufix2 [4]
  reg [1:0] regBMet [0:3];  // ufix2 [4]
  wire dec_0;  // ufix1
  wire dec_1;  // ufix1
  wire dec_2;  // ufix1
  wire dec_3;  // ufix1
  wire [1:0] idx;  // ufix2
  wire [3:0] dec;  // ufix1 [4]
  reg  [3:0] regdec;  // ufix1 [4]
  reg [1:0] regidx;  // ufix2
  wire decoded_1;  // ufix1
  reg  outreg;  // ufix1
  reg signed [31:0] BMetRegister_t_0_0;  // int32
  reg signed [31:0] BMetRegister_t_1;  // int32


  assign Viterbi_Decoder1_in[0] = Viterbi_Decoder1_in_0;
  assign Viterbi_Decoder1_in[1] = Viterbi_Decoder1_in_1;

  // Input Register
  always @(posedge clk or posedge reset)
    begin : InputRegister_process
      if (reset == 1'b1) begin
        regin <= {2{1'b0}};
      end
      else begin
        if (enb) begin
          regin <= Viterbi_Decoder1_in;
        end
      end
    end



  BranchMetric u_BMet_inst (.din_0(regin[0]),  // boolean
                            .din_1(regin[1]),  // boolean
                            .bMet_0(bMet_0),  // ufix2
                            .bMet_1(bMet_1),  // ufix2
                            .bMet_2(bMet_2),  // ufix2
                            .bMet_3(bMet_3)  // ufix2
                            );

  assign bMet[0] = bMet_0;
  assign bMet[1] = bMet_1;
  assign bMet[2] = bMet_2;
  assign bMet[3] = bMet_3;

  // Branch Metric output Register
  always @(posedge clk or posedge reset)
    begin : BMetRegister_process
      if (reset == 1'b1) begin
        for(BMetRegister_t_1 = 32'sd0; BMetRegister_t_1 <= 32'sd3; BMetRegister_t_1 = BMetRegister_t_1 + 32'sd1) begin
          regBMet[BMetRegister_t_1] <= 2'b00;
        end
      end
      else begin
        if (enb) begin
          for(BMetRegister_t_0_0 = 32'sd0; BMetRegister_t_0_0 <= 32'sd3; BMetRegister_t_0_0 = BMetRegister_t_0_0 + 32'sd1) begin
            regBMet[BMetRegister_t_0_0] <= bMet[BMetRegister_t_0_0];
          end
        end
      end
    end



  ACS u_ACS_inst (.clk(clk),
                  .reset(reset),
                  .enb(enb),
                  .acs_in_0(regBMet[0]),  // ufix2
                  .acs_in_1(regBMet[1]),  // ufix2
                  .acs_in_2(regBMet[2]),  // ufix2
                  .acs_in_3(regBMet[3]),  // ufix2
                  .dec_0(dec_0),  // ufix1
                  .dec_1(dec_1),  // ufix1
                  .dec_2(dec_2),  // ufix1
                  .dec_3(dec_3),  // ufix1
                  .idx(idx)  // ufix2
                  );

  assign dec[0] = dec_0;
  assign dec[1] = dec_1;
  assign dec[2] = dec_2;
  assign dec[3] = dec_3;

  // ACS dec output Register
  always @(posedge clk or posedge reset)
    begin : decRegister_process
      if (reset == 1'b1) begin
        regdec <= {4{1'b0}};
      end
      else begin
        if (enb) begin
          regdec <= dec;
        end
      end
    end



  // ACS idx output Register
  always @(posedge clk or posedge reset)
    begin : idxRegister_process
      if (reset == 1'b1) begin
        regidx <= 2'b00;
      end
      else begin
        if (enb) begin
          regidx <= idx;
        end
      end
    end



  Traceback u_Traceback_inst (.clk(clk),
                              .reset(reset),
                              .enb(enb),
                              .dec_0(regdec[0]),  // ufix1
                              .dec_1(regdec[1]),  // ufix1
                              .dec_2(regdec[2]),  // ufix1
                              .dec_3(regdec[3]),  // ufix1
                              .idx(regidx),  // ufix2
                              .decoded(decoded_1)  // ufix1
                              );

  // Viterbi Decoder output Register
  always @(posedge clk or posedge reset)
    begin : DecoderoutputRegister_process
      if (reset == 1'b1) begin
        outreg <= 1'b0;
      end
      else begin
        if (enb) begin
          outreg <= decoded_1;
        end
      end
    end



  // Output data type conversion
  assign decoded = outreg;



endmodule  // Viterbi_Decoder1

